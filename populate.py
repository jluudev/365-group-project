import sqlalchemy
import os
import dotenv
from faker import Faker
import numpy as np

# Load environment variables
dotenv.load_dotenv()

def database_connection_url():
    DB_USER = os.getenv("POSTGRES_USER")
    DB_PASSWD = os.getenv("POSTGRES_PASSWORD")
    DB_SERVER = os.getenv("POSTGRES_SERVER")
    DB_PORT = os.getenv("POSTGRES_PORT")
    DB_NAME = os.getenv("POSTGRES_DB")
    return f"postgresql://{DB_USER}:{DB_PASSWD}@{DB_SERVER}:{DB_PORT}/{DB_NAME}"

# Create a new DB engine based on our connection string
engine = sqlalchemy.create_engine(database_connection_url(), use_insertmanyvalues=True)

fake = Faker()

# Drop and create tables
with engine.begin() as conn:
    conn.execute(sqlalchemy.text("""
    DROP TABLE IF EXISTS targeting;
    DROP TABLE IF EXISTS recruitment;
    DROP TABLE IF EXISTS hero;
    DROP TABLE IF EXISTS guild;
    DROP TABLE IF EXISTS monster;
    DROP TABLE IF EXISTS dungeon;
    DROP TABLE IF EXISTS world;

    CREATE TABLE world (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name TEXT NOT NULL,
        dungeon_capacity INT,
        guild_capacity INT
    );

    CREATE TABLE dungeon (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name TEXT NOT NULL,
        monster_capacity INT,
        party_capacity INT,
        level INT,
        gold_reward INT,
        world_id BIGINT REFERENCES world(id),
        status TEXT DEFAULT 'open'
    );

    CREATE TABLE monster (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        type TEXT NOT NULL,
        level INT,
        health INT,
        power INT,
        dungeon_id BIGINT REFERENCES dungeon(id)
    );

    CREATE TABLE guild (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name TEXT NOT NULL,
        player_capacity INT,
        gold INT,
        world_id BIGINT REFERENCES world(id)
    );

    CREATE TABLE hero (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name TEXT NOT NULL UNIQUE,
        class TEXT,
        power INT,
        health INT,
        xp INT DEFAULT 0,
        age INT DEFAULT 20,
        level INT DEFAULT 1,
        status TEXT DEFAULT 'alive',
        guild_id BIGINT REFERENCES guild(id),
        dungeon_id BIGINT REFERENCES dungeon(id),
        world_id BIGINT REFERENCES world(id)
    );

    CREATE TABLE recruitment (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        hero_id BIGINT REFERENCES hero(id),
        guild_id BIGINT REFERENCES guild(id),
        status TEXT NOT NULL,
        request_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        response_date TIMESTAMP WITH TIME ZONE,
        notes TEXT
    );

    CREATE TABLE targeting (
        id SERIAL PRIMARY KEY,
        hero_id INT REFERENCES hero(id),
        monster_id INT REFERENCES monster(id),
        damage INT NOT NULL DEFAULT 0,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    """))

# Generate fake data
num_worlds = 150
num_guilds = 25000
num_dungeons = 100000
num_monsters = 300000
num_heroes = 600000
num_targetings = 100000

with engine.begin() as conn:
    # Insert worlds
    worlds = [{
        "name": fake.unique.city(),
        "dungeon_capacity": fake.random_int(min=50, max=500),
        "guild_capacity": fake.random_int(min=10, max=100)
    } for _ in range(num_worlds)]
    conn.execute(sqlalchemy.text("""
    INSERT INTO world (name, dungeon_capacity, guild_capacity) 
    VALUES (:name, :dungeon_capacity, :guild_capacity)
    """), worlds)

    # Get world IDs
    world_ids = conn.execute(sqlalchemy.text("SELECT id FROM world")).fetchall()

    # Insert guilds
    guilds = [{
        "name": fake.unique.company(),
        "player_capacity": fake.random_int(min=5, max=50),
        "gold": fake.random_int(min=0, max=10000),
        "world_id": fake.random_element(elements=world_ids).id
    } for _ in range(num_guilds)]
    conn.execute(sqlalchemy.text("""
    INSERT INTO guild (name, player_capacity, gold, world_id) 
    VALUES (:name, :player_capacity, :gold, :world_id)
    """), guilds)

    # Insert dungeons
    dungeons = [{
        "name": fake.unique.street_name(),
        "monster_capacity": fake.random_int(min=10, max=100),
        "party_capacity": fake.random_int(min=1, max=10),
        "level": fake.random_int(min=1, max=100),
        "gold_reward": fake.random_int(min=0, max=5000),
        "world_id": fake.random_element(elements=world_ids).id,
        "status": fake.random_element(elements=["open", "closed"])
    } for _ in range(num_dungeons)]
    conn.execute(sqlalchemy.text("""
    INSERT INTO dungeon (name, monster_capacity, party_capacity, level, gold_reward, world_id, status) 
    VALUES (:name, :monster_capacity, :party_capacity, :level, :gold_reward, :world_id, :status)
    """), dungeons)

    # Get dungeon IDs
    dungeon_ids = conn.execute(sqlalchemy.text("SELECT id FROM dungeon")).fetchall()

    # Insert monsters
    monsters = [{
        "type": fake.word(),
        "level": fake.random_int(min=1, max=100),
        "health": fake.random_int(min=0, max=1000),  # Allow health to be 0 (dead)
        "power": fake.random_int(min=1, max=100),
        "dungeon_id": fake.random_element(elements=dungeon_ids).id
    } for _ in range(num_monsters)]
    conn.execute(sqlalchemy.text("""
    INSERT INTO monster (type, level, health, power, dungeon_id) 
    VALUES (:type, :level, :health, :power, :dungeon_id)
    """), monsters)

    # Get guild IDs
    guild_ids = conn.execute(sqlalchemy.text("SELECT id FROM guild")).fetchall()

    # Insert heroes with unique names
    hero_names = set()
    heroes = []
    while len(heroes) < num_heroes:
        name = f"{fake.first_name()}{fake.random_int(min=100000, max=999999)}"
        if name not in hero_names:
            hero_names.add(name)
            heroes.append({
                "name": name,
                "class": fake.random_element(elements=["Warrior", "Mage", "Archer"]),
                "power": fake.random_int(min=1, max=100),
                "health": fake.random_int(min=0, max=1000),  # Allow health to be 0 (dead)
                "xp": fake.random_int(min=0, max=10000),
                "level": fake.random_int(min=1, max=100),
                "status": fake.random_element(elements=["alive", "dead"]),
                "guild_id": fake.random_element(elements=guild_ids).id if fake.boolean(80) else None,  # 20% chance to be guildless
                "dungeon_id": fake.random_element(elements=dungeon_ids).id,
                "world_id": fake.random_element(elements=world_ids).id
            })
    conn.execute(sqlalchemy.text("""
    INSERT INTO hero (name, class, power, health, xp, level, status, guild_id, dungeon_id, world_id) 
    VALUES (:name, :class, :power, :health, :xp, :level, :status, :guild_id, :dungeon_id, :world_id)
    """), heroes)

    # Get hero and monster IDs for targeting
    hero_ids = conn.execute(sqlalchemy.text("SELECT id FROM hero")).fetchall()
    monster_ids = conn.execute(sqlalchemy.text("SELECT id FROM monster")).fetchall()

    # Insert targetings
    targetings = [{
        "hero_id": fake.random_element(elements=hero_ids).id,
        "monster_id": fake.random_element(elements=monster_ids).id,
        "damage": fake.random_int(min=0, max=100),
        "timestamp": fake.date_time_between(start_date='-5y', end_date='now', tzinfo=None)
    } for _ in range(num_targetings)]
    conn.execute(sqlalchemy.text("""
    INSERT INTO targeting (hero_id, monster_id, damage, timestamp) 
    VALUES (:hero_id, :monster_id, :damage, :timestamp)
    """), targetings)

# Output total rows generated
print("Data generation completed:")
print(f"Worlds: {num_worlds}")
print(f"Guilds: {num_guilds}")
print(f"Dungeons: {num_dungeons}")
print(f"Monsters: {num_monsters}")
print(f"Heroes: {num_heroes}")
print(f"Targetings: {num_targetings}")
